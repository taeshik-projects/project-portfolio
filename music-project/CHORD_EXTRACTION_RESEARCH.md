# 음악 정보 검색(Music Information Retrieval) 관점에서 오케스트라 총보의 코드 진행 자동 추출 연구

이 문서는 오케스트라 총보에서 코드 진행을 자동으로 추출하기 위한 두 가지 핵심 과제, 즉 **적응적 시간 분할(Adaptive Time Segmentation)** 및 **확장된 코드 인식(Extended Chord Recognition)**에 대한 연구 결과와 실용적인 구현 방법을 제시합니다.

## 1. 적응적 시간 분할(Adaptive Time Segmentation)

**목표:** 마디마다 코드 변화 패턴이 다르므로, 실제 코드 변화가 일어나는 시점을 자동으로 감지하는 알고리즘 조사.

### 최신 연구 동향 요약

오케스트라 총보와 같은 **심볼릭 데이터**에서 적응적 시간 분할은 주로 음악 이벤트의 밀도, 하모닉 변화, 그리고 베이스 라인의 움직임을 기반으로 합니다. 오디오 신호 처리에 사용되는 Onset Detection 및 Beat Tracking 기술의 개념은 심볼릭 데이터에도 적용될 수 있지만, 구현 방식은 다릅니다.

*   **Harmonic Change Detection Function (HCDF):** 음악에서 화성적 변화가 일어나는 지점을 감지하는 핵심적인 방법론입니다. 심볼릭 데이터의 경우, 특정 시간 구간 내의 음고(pitch) 정보를 기반으로 피치 클래스 프로파일(Pitch Class Profile, PCP) 또는 크로마(Chroma) 벡터를 생성하고, 연속된 시간 구간 간의 유사도 또는 차이(dissimilarity)를 계산하여 변화 지점을 식별합니다. Degani, Dalai, Leonardi, Migliorati (2015) 등의 연구에서 "Harmonic change detection for musical chords segmentation"이 다루어졌으며, 특히 "Symbolic Harmonic Change Detection"에 대한 연구는 총보 분석에 직접적으로 적용될 수 있습니다.
*   **Onset Detection (심볼릭 데이터):** 악보 데이터에서는 새로운 음표나 화음이 시작되는 시점을 명시적으로 파악할 수 있습니다. 이는 오디오 기반의 onset detection보다 더 명확하게 이벤트 타이밍을 추출하는 것을 가능하게 합니다.
*   **베이스 라인 변화 감지:** 가장 낮은 음정(베이스)의 변화는 종종 화성적 변화, 특히 코드의 근음 변화나 전위(inversion)와 밀접하게 관련됩니다. 베이스 라인의 움직임을 추적하여 중요한 화성적 경계를 감지할 수 있습니다.

### 실용적인 Python 구현 방법 제안 (라이브러리, 알고리즘)

오케스트라 총보가 MusicXML 또는 MIDI와 같은 심볼릭 포맷이라고 가정할 때, 다음과 같은 접근법을 제안합니다.

1.  **악보 파싱 및 음표 데이터 추출:**
    *   **`music21`**: MusicXML 또는 MIDI 파일을 파싱하고, 각 음표(`music21.note.Note`)의 음고(pitch, `music21.pitch.Pitch.ps` 또는 `music21.pitch.Pitch.midi`), 시작 시간(`offset`), 지속 시간(`duration`)을 추출합니다.
    *   **음악 이벤트 타임라인 생성**: 추출된 음표 데이터를 기반으로, 특정 시간 해상도(예: 0.1초 또는 최소 음표 길이 단위)로 모든 활성화된 음고를 포함하는 타임라인을 생성합니다.

2.  **하모닉 변화 감지 (HCDF 구현):**
    *   **피치 클래스 프로파일(PCP) 또는 크로마 벡터 생성**: 각 시간 프레임(예: 0.5초 간격 또는 더 짧게)에서 활성화된 음고들을 기반으로 12개의 피치 클래스(C, C#, D, ..., B)에 대한 강도를 나타내는 PCP 또는 크로마 벡터를 계산합니다. 오케스트라의 경우, 각 악기의 음역대와 음량(dynamics)을 고려한 가중치 부여도 고려할 수 있습니다.
    *   **유사도/거리 측정**: 연속된 PCP/크로마 벡터 간의 코사인 유사도(cosine similarity) 또는 유클리드 거리(Euclidean distance)와 같은 측정 지표를 사용하여 변화 함수(Change Detection Function)를 생성합니다. 값이 낮거나(유사도) 높을수록(거리) 화성적 변화 가능성이 큽니다.
    *   **피크 감지**: 변화 함수에서 로컬 피크를 찾아 화성적 변화 시점으로 식별합니다. `scipy.signal.find_peaks`와 같은 함수를 활용할 수 있습니다.

3.  **베이스 라인 변화 감지:**
    *   각 시간 프레임에서 가장 낮은 음고를 식별합니다.
    *   연속된 프레임에서 베이스 음고가 유의미하게 변화하는 지점(예: 3도 이상 변화)을 찾아 화성적 경계로 간주합니다.

### 우리 프로젝트에 바로 적용 가능한 구체적 접근법

*   **다중 기준 결합**: 단순한 HCDF 피크 감지만으로는 부족할 수 있습니다. Onset detection (새로운 화음의 시작), 베이스 라인 변화, HCDF 피크를 **종합적으로 고려**하여 최종적인 시간 분할 지점을 결정합니다. 예를 들어, HCDF 피크가 발생한 지점에서 동시에 베이스 라인이 크게 변화하거나 새로운 화음이 시작되면, 그 지점을 강력한 화성적 경계로 판단합니다.
*   **문맥 정보 활용**: 오케스트라 총보의 특성상 마디줄(barlines), 박자표(time signature) 등의 구조적 정보는 시간 분할의 중요한 힌트가 될 수 있습니다. 마디 시작점은 잠재적인 코드 변화 지점입니다.
*   **세분화된 분석**: 짧은 음표(예: 16분음표) 단위로 분석하여 빠르게 변화하는 화성적 진행도 놓치지 않도록 합니다. 이후에 일정 시간 동안 동일한 화음이 유지될 경우 병합하는 후처리 과정을 거칠 수 있습니다.

## 2. 확장된 코드 인식(Extended Chord Recognition)

**목표:** 텐션 노트(9th, 11th, 13th)를 포함한 복잡한 코드 인식.

### 최신 연구 동향 요약

확장된 코드 인식은 전통적인 3화음/7화음 인식에서 벗어나, 재즈 화성에서 흔히 사용되는 텐션(9th, 11th, 13th) 및 변형된 텐션(b9, #9, #11, b13)을 포함하는 복잡한 화음을 정확하게 식별하는 것을 목표로 합니다.

*   **Pitch Class (0-11) vs. Pitch Height (옥타브 정보 포함):**
    *   **Pitch Class**: 코드의 기본 성격(Major, Minor, Dominant 등)과 텐션의 존재 여부를 파악하는 데 필수적입니다. 옥타브가 다른 동일한 음정은 같은 피치 클래스로 간주됩니다. 대부분의 코드 인식 알고리즘은 피치 클래스 정보를 기반으로 합니다.
    *   **Pitch Height**: 실제 연주된 음고의 옥타브 정보를 포함합니다. 코드의 전위(inversion), 보이싱(voicing), 그리고 때로는 근음(root)을 결정하는 데 중요한 역할을 합니다. 특히 오케스트라 총보의 경우, 특정 악기가 특정 옥타브에서 연주되는 특징(오케스트레이션)을 분석하는 데 필요합니다.
*   **옥타브 정보가 코드 인식에 미치는 영향:**
    *   **근음/전위 파악**: 가장 낮은 음고(베이스 음)는 코드의 근음 또는 전위를 결정하는 강력한 단서입니다. 옥타브 정보가 없으면 이를 구분하기 어렵습니다.
    *   **보이싱/음향적 특성**: 같은 코드라도 음정들이 어떤 옥타브에 배치되느냐(보이싱)에 따라 음향적 특성이 크게 달라집니다. 오케스트라 분석에서는 이러한 보이싱 정보가 중요합니다.
    *   **텐션의 실제화**: 텐션 음이 특정 옥타브에 존재할 때만 특정 코드(예: Cmaj9)로 인식될 수 있습니다.
*   **재즈/클래식 화성 분석 방법론:**
    *   **재즈**: 텐션 노트와 코드 스케일(chord-scale) 이론을 기반으로 코드를 식별합니다. 주로 텐션이 코드의 색깔을 결정하며, 불완전한 코드(일부 음정 생략)도 문맥상 완전한 코드로 해석합니다.
    *   **클래식**: 기능 화성학(functional harmony)에 기반하여 코드의 기능(Tonic, Dominant, Subdominant)과 진행을 중요하게 여깁니다. 텐션보다는 경과음, 보조음 등 비화성음의 처리와 해결(resolution)에 중점을 둡니다. 오케스트라 총보의 경우, 시대적/스타일적 배경을 고려한 분석이 필요합니다.
*   **기존 음악 이론 소프트웨어 (music21, chordify 등)의 한계와 해결책:**
    *   `music21`은 기본 코드 인식 기능이 강력하지만, 복잡한 재즈 텐션이나 특정 시대의 클래식 화성을 유연하게 해석하는 데 한계가 있을 수 있습니다. 특히, 불협화음이 많은 구간이나 다양한 텐션이 사용된 경우 오인식이 발생할 수 있습니다. 또한, 대규모 총보 분석 시 성능 문제가 발생할 수 있습니다.
    *   `chordify`와 같은 웹 기반 도구는 오디오 입력에 더 중점을 두며, 심볼릭 데이터의 정교한 분석에는 한계가 있습니다.

### 실용적인 Python 구현 방법 제안 (라이브러리, 알고리즘)

1.  **악보 파싱 및 음정 추출:**
    *   **`music21`**: 파싱된 악보에서 특정 시간 프레임에 존재하는 모든 음표의 **피치 클래스(0-11)와 피치 높이(MIDI 번호 또는 `ps` 값)**를 추출합니다.

2.  **확장된 코드 데이터베이스 구축:**
    *   재즈와 클래식에서 사용되는 다양한 코드 유형(Major, minor, dominant, diminished, augmented) 및 텐션(7, 9, #9, b9, 11, #11, b13, 13)을 포함하는 **코드-피치 클래스 세트(Chord-Pitch Class Set) 데이터베이스**를 구축합니다.
    *   각 코드에 대한 가능한 전위(inversion)도 고려하여 베이스 노트와의 관계를 정의합니다.
    *   예: Cmaj9 = {C, E, G, B, D} (피치 클래스: {0, 4, 7, 11, 2})

3.  **코드 매칭 알고리즘:**
    *   **피치 클래스 매칭**: 추출된 피치 클래스 세트와 구축된 코드 데이터베이스의 피치 클래스 세트를 비교하여 가장 일치하는 코드를 찾습니다. 불일치하는 음이 있을 경우(예: 생략된 5음, 비화성음)에도 가장 적합한 코드를 추론하는 로직이 필요합니다.
    *   **베이스 노트 고려**: 추출된 피치 높이에서 가장 낮은 음고를 코드의 베이스로 간주하고, 이를 통해 코드의 근음 또는 전위를 정확하게 결정합니다. 예를 들어, `music21.chord.Chord` 객체는 `root()`와 `bass()` 속성을 제공합니다.
    *   **머신러닝 기반 접근 (선택 사항)**: 대규모 데이터셋이 있다면, 피치 클래스 프로파일이나 크로마 벡터를 입력으로 받아 코드를 분류하는 머신러닝 모델(예: Support Vector Machine, Neural Network)을 훈련시킬 수 있습니다.

4.  **후처리 및 문맥적 추론:**
    *   **오케스트레이션 고려**: 특정 악기가 연주하는 음역대를 고려하여 비화성음과 텐션을 구분하는 데 활용할 수 있습니다.
    *   **기능 화성 분석**: 클래식 음악에서는 코드의 기능적 역할을 분석하여 코드 진행을 보정합니다. (예: V7 - I 진행의 강한 해결)
    *   **재즈 화성 분석**: 재즈에서는 텐션의 중요도가 높고, 코드 스케일 이론을 바탕으로 가능한 텐션을 유추합니다.

### 우리 프로젝트에 바로 적용 가능한 구체적 접근법

*   **`music21` + 커스텀 코드 인식 엔진**: `music21`을 사용하여 악보에서 모든 음정(피치 높이 포함)을 추출한 후, 이를 바탕으로 직접 확장된 코드 인식 로직을 구현합니다.
    *   **단계 1: Pitch Set 추출**: 시간 분할된 각 구간에서 연주되는 모든 음정의 피치 높이를 리스트로 가져옵니다.
    *   **단계 2: 최저음(Bass) 결정**: 이 리스트에서 가장 낮은 음을 베이스로 설정합니다.
    *   **단계 3: Pitch Class Set 생성**: 피치 높이 리스트를 피치 클래스 세트(중복 제거)로 변환합니다.
    *   **단계 4: 코드 템플릿 매칭**: 미리 정의된 확장 코드 템플릿 데이터베이스와 피치 클래스 세트를 비교합니다. 이때, 베이스 노트가 코드의 근음인지, 또는 특정 전위인지 확인하는 로직을 포함합니다.
        *   **유연한 매칭**: 코드 템플릿에 없는 음이 나타나면, 이를 비화성음(non-chord tone) 또는 추가 텐션으로 판단하는 기준을 설정합니다. (예: 템플릿과 80% 이상 일치하고, 베이스가 적절하면 해당 코드로 인식)
    *   **단계 5: 코드명 부여**: 매칭된 코드 템플릿을 기반으로 "Cmaj9", "G7b9#11" 등과 같은 표준 코드 이름을 부여합니다. 이때 `music21.chord.Chord` 객체의 `commonName`이나 `pitchedCommonName` 속성을 참조하여 최종 코드명을 확정할 수 있습니다.
*   **재즈/클래식 화성 규칙 통합**: 코드 인식 후, 재즈 및 클래식 화성 이론 규칙(예: V7b9는 주로 단조의 V7, #11은 Lydian dominant 등)을 적용하여 코드를 정제하고, 코드 진행에 대한 설명을 추가합니다.
*   **우선순위 기반 해석**: 여러 코드가 동시에 유효할 경우, 문맥(이전 코드, 다음 코드, 강조된 음정)을 고려하여 가장 가능성이 높은 코드를 선택하는 우선순위 시스템을 구축합니다. 예를 들어, 오케스트라 총보에서 재즈에서 흔한 매우 복잡한 텐션 코드는 클래식 시대에는 드물었음을 고려합니다.

이 연구 결과를 바탕으로 `/Users/tsk/.openclaw/workspace/music-project/CHORD_EXTRACTION_RESEARCH.md` 파일을 작성했습니다.
